import { Meta, StoryObj } from "@storybook/react-vite";
import { expect, within, userEvent } from "storybook/test";
import {
  PlateMap,
  WellData,
  LayerConfig,
  PlateRegion,
  LegendConfig,
} from "./PlateMap";

/** Helper to add delay between interactive test actions for smoother viewing */
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const meta: Meta<typeof PlateMap> = {
  title: "Organisms/PlateMap",
  component: PlateMap,
  tags: ["autodocs"],
};

export default meta;
type Story = StoryObj<typeof PlateMap>;

/**
 * Generate sample 96-well plate data with WellData format
 */
function generate96WellData(): WellData[] {
  const wells: WellData[] = [];
  const rows = "ABCDEFGH";

  for (let r = 0; r < 8; r++) {
    for (let c = 1; c <= 12; c++) {
      const wellId = `${rows[r]}${c}`;
      // Create some variation - higher values in center, some empty wells
      const baseValue = 5000 + Math.random() * 20000;
      const centerBoost = r >= 2 && r <= 5 && c >= 4 && c <= 9 ? 10000 : 0;

      // Make a few wells empty
      if ((r === 0 && c === 12) || (r === 7 && c === 1)) {
        wells.push({ wellId, values: { RFU: null } });
      } else {
        wells.push({
          wellId,
          values: { RFU: Math.round(baseValue + centerBoost) },
          tooltipData: { sampleId: `S${r * 12 + c}`, concentration: "100 nM" },
        });
      }
    }
  }
  return wells;
}

/**
 * Generate sample 384-well plate data as WellData array
 */
function generate384WellData(): WellData[] {
  const wells: WellData[] = [];
  const rows = "ABCDEFGHIJKLMNOP"; // 16 rows for 384-well plate

  for (let r = 0; r < 16; r++) {
    for (let c = 1; c <= 24; c++) {
      const wellId = `${rows[r]}${c}`;
      // Create a gradient pattern
      const value = 1000 + r * 1000 + c * 500 + Math.random() * 2000;
      wells.push({ wellId, values: { AU: Math.round(value) } });
    }
  }
  return wells;
}

/**
 * Helper to convert 2D grid to WellData array for custom dimensions
 */
function gridToWellData(
  grid: (number | null)[][],
  layerId: string = "Value",
  customLabels?: { rows?: string[]; cols?: string[] }
): WellData[] {
  const wells: WellData[] = [];
  const defaultRows = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

  for (let r = 0; r < grid.length; r++) {
    for (let c = 0; c < grid[r].length; c++) {
      const rowLabel = customLabels?.rows?.[r] ?? defaultRows[r];
      const colLabel = customLabels?.cols?.[c] ?? String(c + 1);
      const wellId = `${rowLabel}${colLabel}`;
      wells.push({ wellId, values: { [layerId]: grid[r][c] } });
    }
  }
  return wells;
}

const layer96WellConfigs: LayerConfig[] = [
  { id: "RFU", name: "Fluorescence", valueUnit: "RFU" },
];

/**
 * 96-well plate with WellData array input
 * Demonstrates the recommended data format with well IDs, values, and tooltipData
 */
export const Plate96Well: Story = {
  args: {
    data: generate96WellData(),
    plateFormat: "96",
    title: "96-Well Plate Assay Results",
    layerConfigs: layer96WellConfigs,
    precision: 0,
    width: 700,
    height: 450,
    onWellClick: (wellData) => {
      console.log(`Clicked ${wellData.wellId}:`, wellData.values, wellData.tooltipData);
    },
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      const title = canvas.getByText("96-Well Plate Assay Results");
      expect(title).toBeInTheDocument();
    });

    await step("Chart container renders", async () => {
      // Verify the Plotly chart rendered by checking for chart title in the DOM
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1051" },
  },
};

/**
 * 384-well plate with WellData array input
 * Demonstrates larger plate format with 16 rows × 24 columns
 */
export const Plate384Well: Story = {
  args: {
    data: generate384WellData(),
    plateFormat: "384",
    title: "384-Well Plate Screening",
    layerConfigs: [{ id: "AU", valueUnit: " AU" }],
    precision: 0,
    width: 900,
    height: 500,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      const title = canvas.getByText("384-Well Plate Screening");
      expect(title).toBeInTheDocument();
    });

    await step("Chart container renders", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1052" },
  },
};

/**
 * 1536-well plate with double-letter row notation (AA-AF)
 * Demonstrates high-density plate format with 32 rows × 48 columns
 */
export const Plate1536Well: Story = {
  args: {
    data: (() => {
      const wells: WellData[] = [];
      // Row labels for 1536-well: A-Z, then AA-AF (32 rows total)
      const singleRows = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const doubleRows = ["AA", "AB", "AC", "AD", "AE", "AF"];
      const allRows = [...singleRows.split(""), ...doubleRows];

      for (let r = 0; r < 32; r++) {
        for (let c = 1; c <= 48; c++) {
          const wellId = `${allRows[r]}${c}`;
          const value = 1000 + r * 500 + c * 100 + Math.random() * 500;
          wells.push({ wellId, values: { Signal: Math.round(value) } });
        }
      }
      return wells;
    })(),
    plateFormat: "1536",
    title: "1536-Well High-Density Plate",
    layerConfigs: [{ id: "Signal", valueUnit: "RFU" }],
    precision: 0,
    width: 1100,
    height: 600,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      const title = canvas.getByText("1536-Well High-Density Plate");
      expect(title).toBeInTheDocument();
    });

    await step("Chart container renders", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1053" },
  },
};

/**
 * Custom plate dimensions
 * Demonstrates using custom rows/columns for non-standard plates
 */
export const CustomDimensions: Story = {
  args: {
    data: gridToWellData(
      [
        [100, 200, 300, 400],
        [150, 250, 350, 450],
        [200, 300, 400, 500],
      ],
      "Concentration"
    ),
    plateFormat: "custom",
    rows: 3,
    columns: 4,
    title: "Custom 3x4 Plate",
    layerConfigs: [{ id: "Concentration", valueUnit: " nM" }],
    precision: 1,
    width: 500,
    height: 350,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      const title = canvas.getByText("Custom 3x4 Plate");
      expect(title).toBeInTheDocument();
    });

    await step("Chart container renders with custom dimensions", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1054" },
  },
};

/**
 * Partial plate with empty wells
 * Demonstrates handling of sparse data and empty wells
 */
export const PartialPlate: Story = {
  args: {
    data: [
      { wellId: "A1", values: { RFU: 5000 } },
      { wellId: "A2", values: { RFU: 7500 } },
      { wellId: "A3", values: { RFU: null } },
      { wellId: "B1", values: { RFU: 6000 } },
      { wellId: "B2", values: { RFU: 8500 } },
      { wellId: "B3", values: { RFU: 9000 } },
      { wellId: "C1", values: { RFU: null } },
      { wellId: "C2", values: { RFU: 7000 } },
      { wellId: "D4", values: { RFU: 12000 } },
      { wellId: "H12", values: { RFU: 25000 } },
    ],
    plateFormat: "96",
    title: "Partial Plate (Sparse Data)",
    layerConfigs: [{ id: "RFU", valueUnit: "RFU" }],
    width: 700,
    height: 450,
    emptyWellColor: "#e0e0e0",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      const title = canvas.getByText("Partial Plate (Sparse Data)");
      expect(title).toBeInTheDocument();
    });

    await step("Chart container renders with sparse data", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1055" },
  },
};

/**
 * Generic heatmap with axis titles
 * Demonstrates using PlateMap as a general-purpose heatmap with custom axis labels
 */
export const GenericHeatmap: Story = {
  args: {
    data: gridToWellData(
      [
        [5000, 10000, 15000, 20000, 25000],
        [10000, 15000, 20000, 25000, 30000],
        [15000, 20000, 25000, 30000, 35000],
        [20000, 25000, 30000, 35000, 40000],
        [25000, 30000, 35000, 40000, 45000],
      ],
      "Value",
      { rows: ["Y1", "Y2", "Y3", "Y4", "Y5"], cols: ["X1", "X2", "X3", "X4", "X5"] }
    ),
    plateFormat: "custom",
    rows: 5,
    columns: 5,
    xLabels: ["X1", "X2", "X3", "X4", "X5"],
    yLabels: ["Y1", "Y2", "Y3", "Y4", "Y5"],
    xTitle: "X Axis",
    yTitle: "Y Axis",
    title: "Generic Heatmap with Custom Labels",
    layerConfigs: [{ id: "Value" }],
    width: 600,
    height: 500,
    precision: 0,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      const title = canvas.getByText("Generic Heatmap with Custom Labels");
      expect(title).toBeInTheDocument();
    });

    await step("Custom axis labels are displayed", async () => {
      // Check for custom X-axis labels
      expect(canvas.getByText("X1")).toBeInTheDocument();
      expect(canvas.getByText("X5")).toBeInTheDocument();
      // Check for custom Y-axis labels
      expect(canvas.getByText("Y1")).toBeInTheDocument();
      expect(canvas.getByText("Y5")).toBeInTheDocument();
    });

    await step("Axis titles are displayed", async () => {
      expect(canvas.getByText("X Axis")).toBeInTheDocument();
      expect(canvas.getByText("Y Axis")).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1056" },
  },
};

/**
 * Auto-generated random data
 * Demonstrates PlateMap with no data - generates random values automatically
 */
export const RandomData: Story = {
  args: {
    plateFormat: "96",
    title: "Auto-generated Random Data",
    xTitle: "Columns",
    yTitle: "Rows",
    valueUnit: " RFU",
    precision: 0,
    width: 800,
    height: 500,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      const title = canvas.getByText("Auto-generated Random Data");
      expect(title).toBeInTheDocument();
    });

    await step("Chart container renders with auto-generated data", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });

    await step("Axis titles are displayed", async () => {
      expect(canvas.getByText("Columns")).toBeInTheDocument();
      expect(canvas.getByText("Rows")).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1057" },
  },
};

/**
 * Categorical visualization mode
 * Demonstrates displaying well types with discrete colors
 */
export const CategoricalVisualization: Story = {
  args: {
    data: (() => {
      const wells: WellData[] = [];
      const rows = "ABCDEFGH";

      for (let r = 0; r < 8; r++) {
        for (let c = 1; c <= 12; c++) {
          const wellId = `${rows[r]}${c}`;
          // First column is controls, last column is blanks, rest are samples or standards
          let wellType: string;
          if (c === 1) wellType = "control";
          else if (c === 12) wellType = "blank";
          else if (r === 0 || r === 7) wellType = "standard";
          else wellType = "sample";

          wells.push({ wellId, values: { Type: wellType } });
        }
      }
      return wells;
    })(),
    plateFormat: "96",
    title: "Categorical Well Types",
    layerConfigs: [
      {
        id: "Type",
        visualizationMode: "categorical",
        categoryColors: {
          sample: "#4575b4",
          control: "#d73027",
          standard: "#fdae61",
          blank: "#f0f0f0",
        },
      },
    ],
    width: 700,
    height: 450,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart renders with title", async () => {
      const title = canvas.getByText("Categorical Well Types");
      expect(title).toBeInTheDocument();
    });

    await step("Legend displays categories", async () => {
      // Check that category labels appear in the legend
      expect(canvas.getByText("sample")).toBeInTheDocument();
      expect(canvas.getByText("control")).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1058" },
  },
};

/**
 * Multi-layer data with layer toggling
 * Demonstrates wells with multiple values and layer switching
 */
export const LayerToggling: Story = {
  args: {
    data: (() => {
      const wells: WellData[] = [];
      const rows = "ABCDEFGH";

      for (let r = 0; r < 8; r++) {
        for (let c = 1; c <= 12; c++) {
          const wellId = `${rows[r]}${c}`;
          const rawValue = 5000 + Math.random() * 20000;
          const normalizedValue = rawValue / 25000;
          const zScore = (rawValue - 15000) / 5000;

          wells.push({
            wellId,
            values: {
              Raw: Math.round(rawValue),
              Normalized: Math.round(normalizedValue * 100) / 100,
              ZScore: Math.round(zScore * 100) / 100,
            },
            tooltipData: { sampleId: `S${r * 12 + c}` },
          });
        }
      }
      return wells;
    })(),
    plateFormat: "96",
    title: "Multi-Layer Assay Data",
    layerConfigs: [
      { id: "Raw", name: "Raw Signal", valueUnit: "RFU", colorScale: "Blues" },
      {
        id: "Normalized",
        name: "Normalized",
        valueMin: 0,
        valueMax: 1,
        colorScale: "Viridis",
      },
      {
        id: "ZScore",
        name: "Z-Score",
        valueMin: -3,
        valueMax: 3,
        colorScale: "RdBu",
      },
    ],
    initialLayerId: "Raw",
    onLayerChange: (layerId) => console.log("Layer changed to:", layerId),
    width: 700,
    height: 450,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Layer toggle buttons are displayed", async () => {
      expect(canvas.getByText("Raw Signal")).toBeInTheDocument();
      expect(canvas.getByText("Normalized")).toBeInTheDocument();
      expect(canvas.getByText("Z-Score")).toBeInTheDocument();
    });

    await step("Chart container renders", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });

    await step("Raw Signal is initially active", async () => {
      const rawButton = canvas.getByText("Raw Signal");
      // Active button has blue background (#4575b4)
      expect(rawButton).toHaveStyle({ backgroundColor: "rgb(69, 117, 180)" });
    });

    await step("Click Normalized layer toggles active state", async () => {
      const normalizedButton = canvas.getByText("Normalized");
      const rawButton = canvas.getByText("Raw Signal");

      // Normalized should be inactive (white background)
      expect(normalizedButton).toHaveStyle({ backgroundColor: "rgb(255, 255, 255)" });

      await sleep(1000); // Delay before click for smoother viewing
      await userEvent.click(normalizedButton);

      // Now Normalized should be active
      expect(normalizedButton).toHaveStyle({ backgroundColor: "rgb(69, 117, 180)" });
      // Raw Signal should be inactive
      expect(rawButton).toHaveStyle({ backgroundColor: "rgb(255, 255, 255)" });
    });

    await step("Click Z-Score layer toggles active state", async () => {
      const zScoreButton = canvas.getByText("Z-Score");
      const normalizedButton = canvas.getByText("Normalized");

      await sleep(1000); // Delay before click for smoother viewing
      await userEvent.click(zScoreButton);

      // Now Z-Score should be active
      expect(zScoreButton).toHaveStyle({ backgroundColor: "rgb(69, 117, 180)" });
      // Normalized should be inactive
      expect(normalizedButton).toHaveStyle({ backgroundColor: "rgb(255, 255, 255)" });
    });

    await step("Click Raw Signal layer to switch back", async () => {
      const rawButton = canvas.getByText("Raw Signal");
      const zScoreButton = canvas.getByText("Z-Score");

      await sleep(1000); // Delay before click for smoother viewing
      await userEvent.click(rawButton);

      // Raw Signal should be active again
      expect(rawButton).toHaveStyle({ backgroundColor: "rgb(69, 117, 180)" });
      // Z-Score should be inactive
      expect(zScoreButton).toHaveStyle({ backgroundColor: "rgb(255, 255, 255)" });
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1059" },
  },
};

/**
 * Region highlighting with PlateRegions
 * Demonstrates rectangular region overlays with borders and fill colors
 */
export const RegionHighlighting: Story = {
  args: {
    data: (() => {
      const wells: WellData[] = [];
      const rows = "ABCDEFGH";

      for (let r = 0; r < 8; r++) {
        for (let c = 1; c <= 12; c++) {
          const wellId = `${rows[r]}${c}`;
          wells.push({
            wellId,
            values: { Signal: Math.round(5000 + Math.random() * 20000) },
          });
        }
      }
      return wells;
    })(),
    plateFormat: "96",
    title: "Plate with Region Highlights",
    layerConfigs: [{ id: "Signal", valueUnit: "RFU" }],
    regions: [
      {
        id: "positive-controls",
        name: "Positive Controls",
        wells: "A1:A6",
        borderColor: "#d73027",
        borderWidth: 3,
        fillColor: "rgba(215, 48, 39, 0.1)",
      },
      {
        id: "negative-controls",
        name: "Negative Controls",
        wells: "A7:A12",
        borderColor: "#4575b4",
        borderWidth: 3,
        fillColor: "rgba(69, 117, 180, 0.1)",
      },
      {
        id: "samples",
        name: "Sample Area",
        wells: "B1:H12",
        borderColor: "#1a9850",
        borderWidth: 2,
      },
    ] as PlateRegion[],
    width: 700,
    height: 500,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart renders with title", async () => {
      const title = canvas.getByText("Plate with Region Highlights");
      expect(title).toBeInTheDocument();
    });

    await step("Region legend items are displayed", async () => {
      expect(canvas.getByText("Positive Controls")).toBeInTheDocument();
      expect(canvas.getByText("Negative Controls")).toBeInTheDocument();
      expect(canvas.getByText("Sample Area")).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1060" },
  },
};

/**
 * Custom category colors
 * Demonstrates overriding default categorical colors
 */
export const CustomCategoryColors: Story = {
  args: {
    data: (() => {
      const wells: WellData[] = [];
      const rows = "ABCDEFGH";
      const statuses = ["pass", "fail", "pending", "review"];

      for (let r = 0; r < 8; r++) {
        for (let c = 1; c <= 12; c++) {
          const wellId = `${rows[r]}${c}`;
          const status = statuses[Math.floor(Math.random() * statuses.length)];
          wells.push({ wellId, values: { QCStatus: status } });
        }
      }
      return wells;
    })(),
    plateFormat: "96",
    title: "QC Status with Custom Colors",
    layerConfigs: [
      {
        id: "QCStatus",
        name: "QC Status",
        visualizationMode: "categorical",
        categoryColors: {
          pass: "#2ca02c",
          fail: "#d62728",
          pending: "#ff7f0e",
          review: "#9467bd",
        },
      },
    ],
    width: 700,
    height: 450,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Legend shows QC statuses", async () => {
      expect(canvas.getByText("pass")).toBeInTheDocument();
      expect(canvas.getByText("fail")).toBeInTheDocument();
    });

    await step("Chart container renders", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1061" },
  },
};

/**
 * Mixed value types (numeric and categorical)
 * Demonstrates layers with both heatmap and categorical visualization
 */
export const MixedValueTypes: Story = {
  args: {
    data: (() => {
      const wells: WellData[] = [];
      const rows = "ABCDEFGH";
      const statuses = ["positive", "negative", "inconclusive"];

      for (let r = 0; r < 8; r++) {
        for (let c = 1; c <= 12; c++) {
          const wellId = `${rows[r]}${c}`;
          const fluorescence = Math.round(5000 + Math.random() * 20000);
          const status = statuses[Math.floor(Math.random() * statuses.length)];

          wells.push({
            wellId,
            values: {
              Fluorescence: fluorescence,
              Status: status,
            },
            tooltipData: { well: wellId },
          });
        }
      }
      return wells;
    })(),
    plateFormat: "96",
    title: "Mixed Numeric and Categorical Data",
    layerConfigs: [
      {
        id: "Fluorescence",
        name: "Fluorescence",
        visualizationMode: "heatmap",
        valueUnit: "RFU",
        colorScale: "Viridis",
      },
      {
        id: "Status",
        name: "Call Status",
        visualizationMode: "categorical",
        categoryColors: {
          positive: "#d73027",
          negative: "#4575b4",
          inconclusive: "#fdae61",
        },
      },
    ],
    initialLayerId: "Fluorescence",
    width: 700,
    height: 450,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Both layer buttons are displayed", async () => {
      expect(canvas.getByText("Fluorescence")).toBeInTheDocument();
      expect(canvas.getByText("Call Status")).toBeInTheDocument();
    });

    await step("Fluorescence (heatmap) is initially active", async () => {
      const fluorescenceButton = canvas.getByText("Fluorescence");
      expect(fluorescenceButton).toHaveStyle({ backgroundColor: "rgb(69, 117, 180)" });
    });

    await step("Switch to Call Status (categorical) layer", async () => {
      const callStatusButton = canvas.getByText("Call Status");
      const fluorescenceButton = canvas.getByText("Fluorescence");

      await sleep(1000);
      await userEvent.click(callStatusButton);

      // Call Status should now be active
      expect(callStatusButton).toHaveStyle({ backgroundColor: "rgb(69, 117, 180)" });
      // Fluorescence should be inactive
      expect(fluorescenceButton).toHaveStyle({ backgroundColor: "rgb(255, 255, 255)" });
    });

    await step("Categorical legend appears when Call Status is active", async () => {
      // Check that categorical legend items appear
      expect(canvas.getByText("positive")).toBeInTheDocument();
      expect(canvas.getByText("negative")).toBeInTheDocument();
      expect(canvas.getByText("inconclusive")).toBeInTheDocument();
    });

    await step("Switch back to Fluorescence (heatmap) layer", async () => {
      const fluorescenceButton = canvas.getByText("Fluorescence");

      await sleep(1000);
      await userEvent.click(fluorescenceButton);

      // Fluorescence should be active again
      expect(fluorescenceButton).toHaveStyle({ backgroundColor: "rgb(69, 117, 180)" });
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1062" },
  },
};

/**
 * Legend configuration options
 * Demonstrates legend positioning and styling
 */
export const LegendConfiguration: Story = {
  args: {
    data: (() => {
      const wells: WellData[] = [];
      const rows = "ABCDEFGH";
      const types = ["sample", "control", "standard"];

      for (let r = 0; r < 8; r++) {
        for (let c = 1; c <= 12; c++) {
          const wellId = `${rows[r]}${c}`;
          const type = types[Math.floor(Math.random() * types.length)];
          wells.push({ wellId, values: { WellType: type } });
        }
      }
      return wells;
    })(),
    plateFormat: "96",
    title: "Legend at Bottom with Custom Styling",
    layerConfigs: [
      {
        id: "WellType",
        visualizationMode: "categorical",
        categoryColors: {
          sample: "#4575b4",
          control: "#d73027",
          standard: "#fdae61",
        },
      },
    ],
    legendConfig: {
      position: "bottom", // Tests bottom legend position code path (lines 1485-1489)
      fontSize: 14,
      itemSpacing: 16,
      swatchSize: 20,
      title: "Well Types",
    } as LegendConfig,
    width: 700,
    height: 500,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Legend title is displayed", async () => {
      expect(canvas.getByText("Well Types")).toBeInTheDocument();
    });

    await step("Legend items are displayed", async () => {
      expect(canvas.getByText("sample")).toBeInTheDocument();
      expect(canvas.getByText("control")).toBeInTheDocument();
      expect(canvas.getByText("standard")).toBeInTheDocument();
    });
  },
  parameters: {
    // Auto-generated by sync-storybook-zephyr - do not add manually
    zephyr: { testCaseId: "SW-T1063" },
  },
};

/**
 * Hidden UI elements (showColorBar=false, showLegend=false)
 * Tests rendering without colorbar and legend, including horizontal legend position
 */
export const HiddenUIElements: Story = {
  args: {
    data: (() => {
      const wells: WellData[] = [];
      const rows = "ABCDEFGH";
      const types = ["sample", "control"];

      for (let r = 0; r < 8; r++) {
        for (let c = 1; c <= 12; c++) {
          const wellId = `${rows[r]}${c}`;
          const type = types[(r + c) % 2];
          wells.push({ wellId, values: { Type: type } });
        }
      }
      return wells;
    })(),
    plateFormat: "96",
    title: "Hidden UI Elements",
    layerConfigs: [
      {
        id: "Type",
        visualizationMode: "categorical",
        categoryColors: {
          sample: "#4575b4",
          control: "#d73027",
        },
      },
    ],
    showLegend: false,
    showColorBar: false,
    legendConfig: {
      position: "top", // Tests horizontal legend position code path
    } as LegendConfig,
    width: 700,
    height: 450,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Hidden UI Elements")).toBeInTheDocument();
    });

    await step("Legend items are NOT visible", async () => {
      expect(canvas.queryByText("sample")).not.toBeInTheDocument();
      expect(canvas.queryByText("control")).not.toBeInTheDocument();
    });

    await step("Chart container renders without legend/colorbar", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};

/**
 * Edge cases: NaN/Infinity values, null values
 * Tests graceful handling of invalid numeric values (converted to null)
 */
export const EdgeCases: Story = {
  args: {
    data: gridToWellData(
      [
        [100, NaN, null, Infinity],
        [150, 250, -Infinity, 450],
        [NaN, null, 400, 500],
        [200, 300, NaN, 550],
      ],
      "AU"
    ),
    plateFormat: "custom",
    rows: 4,
    columns: 4,
    title: "Edge Cases Test",
    layerConfigs: [{ id: "AU", valueUnit: " AU" }],
    width: 500,
    height: 400,
    showColorBar: true,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Edge Cases Test")).toBeInTheDocument();
    });

    await step("Chart renders without errors despite NaN/Infinity/null values", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};

/**
 * Uniform values: all wells have the same value (min === max edge case)
 * Also tests left legend position for categorical data
 */
export const UniformValuesAndLeftLegend: Story = {
  args: {
    data: gridToWellData(
      [
        [42.0, 42.0, 42.0],
        [42.0, 42.0, 42.0],
        [42.0, 42.0, 42.0],
      ],
      "Value"
    ),
    plateFormat: "custom",
    rows: 3,
    columns: 3,
    title: "Uniform Values Test",
    layerConfigs: [{ id: "Value" }],
    showColorBar: true,
    width: 500,
    height: 400,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Uniform Values Test")).toBeInTheDocument();
    });

    await step("Chart renders with uniform values", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};

/**
 * Categorical data with left legend position
 * Tests left legend rendering code path (lines 1121, 1471-1475)
 */
export const CategoricalLeftLegend: Story = {
  args: {
    data: [
      { wellId: "A1", values: { Type: "sample" } },
      { wellId: "A2", values: { Type: "control" } },
      { wellId: "B1", values: { Type: "sample" } },
      { wellId: "B2", values: { Type: "control" } },
    ],
    plateFormat: "custom",
    rows: 2,
    columns: 2,
    title: "Categorical with Left Legend",
    layerConfigs: [
      {
        id: "Type",
        visualizationMode: "categorical",
        categoryColors: {
          sample: "#4575b4",
          control: "#d73027",
        },
      },
    ],
    legendConfig: {
      position: "left",
      title: "Types",
    } as LegendConfig,
    width: 500,
    height: 400,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Categorical with Left Legend")).toBeInTheDocument();
    });

    await step("Legend is rendered on left", async () => {
      expect(canvas.getByText("Types")).toBeInTheDocument();
      expect(canvas.getByText("sample")).toBeInTheDocument();
      expect(canvas.getByText("control")).toBeInTheDocument();
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};

/**
 * Well click interaction
 * Tests the onWellClick callback by simulating Plotly click events
 */
export const WellClickInteraction: Story = {
  args: {
    data: [
      { wellId: "A1", values: { Value: 100 }, tooltipData: { sample: "S001" } },
      { wellId: "A2", values: { Value: 200 }, tooltipData: { sample: "S002" } },
      { wellId: "B1", values: { Value: 300 }, tooltipData: { sample: "S003" } },
      { wellId: "B2", values: { Value: 400 }, tooltipData: { sample: "S004" } },
    ],
    plateFormat: "custom",
    rows: 2,
    columns: 2,
    title: "Clickable Wells",
    layerConfigs: [{ id: "Value", valueUnit: "RFU" }],
    width: 400,
    height: 350,
    onWellClick: (wellData) => {
      // Store clicked well data on window for test verification
      (window as unknown as Record<string, unknown>).lastClickedWell = wellData;
    },
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Clickable Wells")).toBeInTheDocument();
    });

    await step("Chart container renders with click handler", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });

    await step("Simulate Plotly click event on well A1", async () => {
      const plotContainer = canvasElement.querySelector(
        ".js-plotly-plot"
      ) as HTMLElement & { emit?: (eventName: string, data: unknown) => void };
      expect(plotContainer).toBeInTheDocument();

      // Trigger a plotly_click event with mock data for well A1
      // Plotly attaches event handlers that we can trigger directly
      if (plotContainer && typeof plotContainer.emit === "function") {
        plotContainer.emit("plotly_click", {
          points: [{ x: 1, y: "A", pointIndex: 0 }],
        });
      }
    });

    await step("Wells are clickable (chart accepts pointer events)", async () => {
      // Verify the plot has interactive elements by checking for marker points
      const plotContainer = canvasElement.querySelector(".js-plotly-plot");
      expect(plotContainer).toBeInTheDocument();
      // Plotly renders SVG elements for scatter markers
      const markers = canvasElement.querySelectorAll(".scatterlayer .trace");
      expect(markers.length).toBeGreaterThan(0);
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};

/**
 * Named Plotly colorscale (string format)
 * Tests using a string colorscale like "Viridis" instead of array
 */
export const StringColorscale: Story = {
  args: {
    data: generate384WellData(),
    plateFormat: "384",
    title: "Using Viridis Colorscale",
    colorScale: "Viridis",
    layerConfigs: [{ id: "AU" }],
    width: 900,
    height: 500,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Using Viridis Colorscale")).toBeInTheDocument();
    });

    await step("Chart renders with string colorscale", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};

/**
 * Custom value range overrides
 * Tests valueMin and valueMax props to override auto-calculated range
 */
export const ValueRangeOverride: Story = {
  args: {
    data: gridToWellData(
      [
        [100, 200, 300],
        [150, 250, 350],
        [200, 300, 400],
      ],
      "AU"
    ),
    plateFormat: "custom",
    rows: 3,
    columns: 3,
    title: "Custom Value Range (0-500)",
    valueMin: 0,
    valueMax: 500,
    layerConfigs: [{ id: "AU", valueUnit: " AU" }],
    width: 500,
    height: 400,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Custom Value Range (0-500)")).toBeInTheDocument();
    });

    await step("Chart renders with custom range", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};

/**
 * Colorbar with title (heatmap legend title)
 * Tests legendConfig.title with heatmap mode
 */
export const ColorbarWithTitle: Story = {
  args: {
    data: generate96WellData(),
    plateFormat: "96",
    title: "Heatmap with Colorbar Title",
    layerConfigs: [{ id: "RFU", name: "Fluorescence", valueUnit: "RFU" }],
    legendConfig: {
      position: "right",
      title: "Signal Intensity",
    } as LegendConfig,
    width: 800,
    height: 500,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Heatmap with Colorbar Title")).toBeInTheDocument();
    });

    await step("Chart container renders", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};



/**
 * Invalid regions: tests graceful handling of invalid/out-of-bounds region definitions
 * Covers invalid well format and regions extending beyond plate dimensions
 */
export const InvalidRegions: Story = {
  args: {
    data: gridToWellData(
      [
        [100, 200, 300],
        [150, 250, 350],
      ],
      "Value"
    ),
    plateFormat: "custom",
    rows: 2,
    columns: 3,
    layerConfigs: [{ id: "Value" }],
    title: "Invalid Regions Test",
    regions: [
      {
        id: "invalid-format",
        name: "Invalid Format",
        wells: "INVALID:A3", // Invalid format - should be gracefully ignored
        borderColor: "#d73027",
        borderWidth: 2,
      },
      {
        id: "oob-region",
        name: "Out of Bounds",
        wells: "A1:Z99", // Extends beyond 2x3 plate
        borderColor: "#ff7f0e",
        borderWidth: 2,
      },
      {
        id: "valid-region",
        name: "Valid Region",
        wells: "A1:B2",
        borderColor: "#4575b4",
        borderWidth: 2,
      },
    ] as PlateRegion[],
    width: 500,
    height: 400,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("Chart title is displayed", async () => {
      expect(canvas.getByText("Invalid Regions Test")).toBeInTheDocument();
    });

    await step("Valid region is still rendered", async () => {
      expect(canvas.getByText("Valid Region")).toBeInTheDocument();
    });

    await step("Chart still renders despite invalid regions", async () => {
      const container = canvasElement.querySelector(".js-plotly-plot");
      expect(container).toBeInTheDocument();
    });
  },
  parameters: {
    zephyr: { testCaseId: "" },
  },
};